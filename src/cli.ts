#!/usr/bin/env node

import tmp = require("tmp");
import fs = require("node:fs/promises");
import util = require("node:util");
import path = require("node:path");
import child_process = require("node:child_process");
import commander = require("commander");
import { parseSTL } from "./stl";
import { generateMultiview } from "./views/multiview";
const { program } = commander;
const execFile = util.promisify(child_process.execFile);

interface Options {
    list: boolean;
    defines: string[];
    multiview: boolean;
}

const conventions = {
    pascal: /^module ([A-Z]\w+)/gm,
    all: /^module (\w+)/gm,
    underscore: /^module ([^_]\w+)/gm
} as const;

program
    .name('scadr')
    .option('-d, --define <value>', `variable definitions`, collect, [])
    .option('-m, --module <name>', `specific module to render`, collect, [])
    .addOption(new commander.Option('-c, --convention <kind>', 'top-level naming convention').choices(['auto', ...Object.keys(conventions)]).default("auto"))
    .option('-l, --list', `list modules without rendering`)
    .option('--dry', `dry run (show what would happen)`)
    .option('--multiview', `generate multiview orthographic projection images`)
    .argument("<path>", `.scad file to render`)
    .action(main);
program.parse();

function main(filePath: string, options: Options) {
    asyncMain(filePath, options).then(() => { });
}

async function asyncMain(filePath: string, options: any) {
    const fullPath = path.resolve(filePath);
    const ospath = await findOpenScad();
    const tasks: Promise<any>[] = [];
    if (options.list) {
        console.log("Discovered modules:");
        for (const p of await getPartsToRender()) {
            console.log(` * ${p}`);
        }
        return;
    }

    const parts = options.module.length ? options.module : await getPartsToRender();
    
    if (options.multiview) {
        // Process multiview rendering
        await processMultiview(parts);
    } else {
        // Standard STL rendering
        for (const p of parts) {
            tasks.push(processModule(p));
        }
        for (const p of tasks) await p;
    }
    console.log(`Done!`);

    async function getPartsToRender(): Promise<string[]> {
        const fileContent = await fs.readFile(filePath, { encoding: "utf-8" });

        let modules;
        if (options.convention === 'auto') {
            const allModules = findModules(conventions.all);
            const pascalModules = findModules(conventions.pascal);
            const underscore = findModules(conventions.underscore);
            if ((pascalModules.length > 0) && (pascalModules.length < allModules.length)) {
                return pascalModules;
            } else if ((underscore.length > 0) && (underscore.length < allModules.length)) {
                return underscore;
            } else {
                return allModules;
            }
        }
        return findModules(conventions[options.convention as keyof typeof conventions]);

        function findModules(rgx: RegExp) {
            return [...fileContent.matchAll(rgx)].map(g => g[1]);
        }
    }

    async function processModule(moduleName: string) {
        // Generate temp file contents
        const tempPath = tmp.tmpNameSync({ postfix: ".scad" });
        const tempFileContents = `// Generated by scadr\nuse <${fullPath}>\n${moduleName}();`;
        // Write out the temp file
        await fs.writeFile(tempPath, tempFileContents, { encoding: "utf-8" });

        const outFile = `${filePath.replace(/\.scad/i, `-${moduleName}.stl`)}`;
        const args = getArgs(tempPath, outFile);
        console.log(`Rendering ${moduleName} to ${outFile}...`);
        if (options.dry) {
            console.log(`${ospath} ${args.join(" ")}`);
        } else {
            await execFile(ospath, args);
        }
        await fs.unlink(tempPath);
    }

    async function processMultiview(moduleNames: string[]) {
        // First, render all modules to STL files
        const stlFiles: string[] = [];
        
        for (const moduleName of moduleNames) {
            const stlFile = `${filePath.replace(/\.scad/i, `-${moduleName}.stl`)}`;
            stlFiles.push(stlFile);
            
            // Only render if file doesn't exist or in dry mode
            if (options.dry) {
                console.log(`Would render ${moduleName} to ${stlFile} for multiview`);
            } else {
                try {
                    await fs.access(stlFile);
                    console.log(`Using existing ${stlFile} for multiview...`);
                } catch {
                    // File doesn't exist, render it
                    console.log(`Rendering ${moduleName} to ${stlFile} for multiview...`);
                    await processModule(moduleName);
                }
            }
        }
        
        if (!options.dry) {
            // Parse STL files and generate multiview image
            const models = [];
            for (const stlFile of stlFiles) {
                try {
                    const model = await parseSTL(stlFile);
                    models.push(model);
                } catch (error) {
                    console.warn(`Warning: Could not parse STL file ${stlFile}:`, error);
                }
            }
            
            if (models.length > 0) {
                const outputImage = `${filePath.replace(/\.scad/i, '-multiview.png')}`;
                console.log(`Generating multiview image: ${outputImage}...`);
                
                await generateMultiview(models, {
                    width: 3200,
                    height: 2400,
                    outputPath: outputImage
                });
                
                console.log(`Multiview image saved to ${outputImage}`);
            } else {
                console.error(`No valid STL files found for multiview rendering`);
            }
        }
    }

    function getArgs(inputFile: string, outFile: string): string[] {
        const opts = [
            `--o`, outFile,
            `--export-format`, 'binstl'
        ];
        for (const def of options.define) {
            opts.push('--D', def);
        }
        opts.push(inputFile);
        return opts;
    }
}

async function findOpenScad() {
    const candidateRoots = [
        process.env['OPENSCADPATH'],
        // Windows
        winpath('ProgramFiles'),
        winpath('ProgramFiles(x86)'),
        // Mac
        '/Applications/OpenSCAD.app/Contents/MacOS/OpenSCAD',
        // Linux [?]
        '/usr/bin/openscad'

    ].filter(p => !!p) as string[];

    for (const candidate of candidateRoots) {
        try {
            const stat = await fs.stat(candidate, {})
            if (await fs.stat(candidate)) {
                return candidate;
            }
        } catch {
            // Didn't exist; carry on
        }
    }

    console.error("Unable to find OpenSCAD; set OPENSCADPATH environment variable");
    return process.exit(-1);
}

function winpath(env: string) {
    const val = process.env[env];
    if (val) {
        return path.join(val, "OpenSCAD", "openscad.com");
    }
    return undefined;
}

function collect(value: string, previous: string[]) {
    return [...previous, value];
}
