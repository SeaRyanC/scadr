#!/usr/bin/env node

import tmp = require("tmp");
import fs = require("node:fs/promises");
import fsSync = require("node:fs");
import util = require("node:util");
import path = require("node:path");
import child_process = require("node:child_process");
import commander = require("commander");
import archiver = require("archiver");
const { program } = commander;
const execFile = util.promisify(child_process.execFile);

interface Options {
    list: boolean;
    defines: string[];
    zip: boolean;
    images: boolean;
}

const conventions = {
    pascal: /^module ([A-Z]\w+)/gm,
    all: /^module (\w+)/gm,
    underscore: /^module ([^_]\w+)/gm
} as const;

program
    .name('scadr')
    .option('-d, --define <value>', `variable definitions`, collect, [])
    .option('-m, --module <name>', `specific module to render`, collect, [])
    .addOption(new commander.Option('-c, --convention <kind>', 'top-level naming convention').choices(['auto', ...Object.keys(conventions)]).default("auto"))
    .option('-l, --list', `list modules without rendering`)
    .option('--dry', `dry run (show what would happen)`)
    .option('--zip', `create zip file with all outputs`)
    .option('--images', `generate images alongside STL files (requires --zip)`)
    .argument("<path>", `.scad file to render`)
    .action(main);
program.parse();

function main(filePath: string, options: Options) {
    asyncMain(filePath, options).then(() => { });
}

async function asyncMain(filePath: string, options: any) {
    const fullPath = path.resolve(filePath);
    const ospath = await findOpenScad();
    const tasks: Promise<any>[] = [];
    
    // Validate options
    if (options.images && !options.zip) {
        console.error("Error: --images requires --zip option");
        process.exit(1);
    }
    
    if (options.list) {
        console.log("Discovered modules:");
        for (const p of await getPartsToRender()) {
            console.log(` * ${p}`);
        }
        return;
    }

    // Create temp directory for zip mode
    let tempDir: string | undefined;
    let outputFiles: string[] = [];
    
    if (options.zip) {
        tempDir = tmp.dirSync({ unsafeCleanup: true }).name;
        console.log(`Using temporary directory: ${tempDir}`);
    }

    const parts = options.module.length ? options.module : await getPartsToRender();
    for (const p of parts) {
        tasks.push(processModule(p));
    }
    for (const p of tasks) await p;
    
    if (options.zip && tempDir) {
        await createZipFile(tempDir, outputFiles);
    }
    
    console.log(`Done!`);

    async function getPartsToRender(): Promise<string[]> {
        const fileContent = await fs.readFile(filePath, { encoding: "utf-8" });

        let modules;
        if (options.convention === 'auto') {
            const allModules = findModules(conventions.all);
            const pascalModules = findModules(conventions.pascal);
            const underscore = findModules(conventions.underscore);
            if ((pascalModules.length > 0) && (pascalModules.length < allModules.length)) {
                return pascalModules;
            } else if ((underscore.length > 0) && (underscore.length < allModules.length)) {
                return underscore;
            } else {
                return allModules;
            }
        }
        return findModules(conventions[options.convention as keyof typeof conventions]);

        function findModules(rgx: RegExp) {
            return [...fileContent.matchAll(rgx)].map(g => g[1]);
        }
    }

    async function processModule(moduleName: string) {
        // Generate temp file contents
        const tempPath = tmp.tmpNameSync({ postfix: ".scad" });
        const tempFileContents = `// Generated by scadr\nuse <${fullPath}>\n${moduleName}();`;
        // Write out the temp file
        await fs.writeFile(tempPath, tempFileContents, { encoding: "utf-8" });

        let outFile: string;
        if (options.zip && tempDir) {
            // In zip mode, output to temp directory without scad filename prefix
            outFile = path.join(tempDir, `${moduleName}.stl`);
        } else {
            // Normal mode - output to current directory with scad filename prefix
            outFile = `${filePath.replace(/\.scad/i, `-${moduleName}.stl`)}`;
        }
        
        outputFiles.push(outFile);
        
        let args = getArgs(tempPath, outFile);
        console.log(`Rendering ${moduleName} to ${outFile}...`);
        if (options.dry) {
            console.log(`${ospath} ${args.join(" ")}`);
        } else {
            await execFile(ospath, args);
        }
        
        // Generate image if requested
        if (options.images && options.zip && tempDir) {
            const imageFile = path.join(tempDir, `${moduleName}.png`);
            const imageArgs = getImageArgs(tempPath, imageFile);
            console.log(`Rendering image ${moduleName} to ${imageFile}...`);
            if (!options.dry) {
                await execFile(ospath, imageArgs);
            }
            outputFiles.push(imageFile);
        }
        
        await fs.unlink(tempPath);
    }

    function getArgs(inputFile: string, outFile: string): string[] {
        const opts = [
            `--o`, outFile,
            `--export-format`, 'binstl'
        ];
        for (const def of options.define) {
            opts.push('--D', def);
        }
        opts.push(inputFile);
        return opts;
    }
    
    function getImageArgs(inputFile: string, outFile: string): string[] {
        const opts = [
            `--o`, outFile,
            `--export-format`, 'png',
            `--colorscheme`, 'BeforeDawn',
            `--imgsize`, '1024,768'
        ];
        for (const def of options.define) {
            opts.push('--D', def);
        }
        opts.push(inputFile);
        return opts;
    }
    
    async function createZipFile(tempDir: string, outputFiles: string[]) {
        const scadBaseName = path.basename(filePath, '.scad');
        const zipFileName = `${scadBaseName}.zip`;
        
        console.log(`Creating zip file: ${zipFileName}`);
        
        // Copy original scad file to temp directory
        const scadDestination = path.join(tempDir, path.basename(filePath));
        await fs.copyFile(filePath, scadDestination);
        
        // Create zip archive
        const output = fsSync.createWriteStream(zipFileName);
        const archive = archiver('zip', { zlib: { level: 9 } });
        
        return new Promise<void>((resolve, reject) => {
            output.on('close', () => {
                console.log(`Zip file created: ${zipFileName} (${archive.pointer()} total bytes)`);
                resolve();
            });
            
            archive.on('error', (err: any) => {
                reject(err);
            });
            
            archive.pipe(output);
            
            // Add all files from temp directory
            archive.directory(tempDir, false);
            
            archive.finalize();
        });
    }
}

async function findOpenScad() {
    const candidateRoots = [
        process.env['OPENSCADPATH'],
        // Windows
        winpath('ProgramFiles'),
        winpath('ProgramFiles(x86)'),
        // Mac
        '/Applications/OpenSCAD.app/Contents/MacOS/OpenSCAD',
        // Linux [?]
        '/usr/bin/openscad'

    ].filter(p => !!p) as string[];

    for (const candidate of candidateRoots) {
        try {
            const stat = await fs.stat(candidate, {})
            if (await fs.stat(candidate)) {
                return candidate;
            }
        } catch {
            // Didn't exist; carry on
        }
    }

    console.error("Unable to find OpenSCAD; set OPENSCADPATH environment variable");
    return process.exit(-1);
}

function winpath(env: string) {
    const val = process.env[env];
    if (val) {
        return path.join(val, "OpenSCAD", "openscad.com");
    }
    return undefined;
}

function collect(value: string, previous: string[]) {
    return [...previous, value];
}
